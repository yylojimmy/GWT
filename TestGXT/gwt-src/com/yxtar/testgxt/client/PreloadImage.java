package com.yxtar.testgxt.client;import java.util.ArrayList;import java.util.List;import com.google.gwt.dom.client.Style.Display;import com.google.gwt.dom.client.Style.Overflow;import com.google.gwt.dom.client.Style.Position;import com.google.gwt.dom.client.Style.Unit;import com.google.gwt.event.dom.client.ClickHandler;import com.google.gwt.event.dom.client.LoadEvent;import com.google.gwt.event.dom.client.LoadHandler;import com.google.gwt.event.dom.client.MouseOverHandler;import com.google.gwt.event.shared.HasHandlers;import com.google.gwt.user.client.Timer;import com.google.gwt.user.client.ui.Composite;import com.google.gwt.user.client.ui.HasHorizontalAlignment;import com.google.gwt.user.client.ui.HasVerticalAlignment;import com.google.gwt.user.client.ui.Image;import com.google.gwt.user.client.ui.PopupPanel;import com.google.gwt.user.client.ui.SimplePanel;import com.google.gwt.user.client.ui.VerticalPanel;/** * PreloadImage an image widget which can resize the image without change the * image size ratio, it also support image preload * @author jimmylo *  */public class PreloadImage extends Composite implements HasHandlers {	/**	 * a popup panel for preload image usage	 */	protected PopupPanel preloadPanel;	protected Image image;	/**	 * image url path	 */	protected String url;	protected SimplePanel mainPanel;	protected int width = 0; // image width	protected int height = 0; // image height	protected int originalWidth = 0;	protected int originalheight = 0;	protected List<MouseOverHandler> mouseOverHandlers = new ArrayList<MouseOverHandler>();	protected List<PreloadImageEventHandler> preloadImageEventHandlers;	protected List<ClickHandler> cliskHandlers = new ArrayList<ClickHandler>();	/**	 * animateEffect - a flag to enable the animation when the image is displaying	 */	protected boolean animationEffectFlg = false;	/**	 * animationTime - the duration for the animation when the image is displaying	 */	protected double animationTime = 0.2;	/**	 * flag indicating whether the image is preloaded or not	 */	protected boolean preloadFlg = true;	/**	 * hideFlag - true if the image is hidding	 */	private boolean hideFlag = false;		/**	 * cropMode - true if the image should be cropped	 */	private boolean cropMode = false;		/**	 * relativeDirectionFlag - true for move horizontally, false to move vertically	 */	private boolean relativeDirectionFlag = false;		/**	 * relativeMoveDistance - css distance to move in cropMode	 */	private int relativeMoveDistance = 0;	/**	 * Constructor	 * @param url image url	 * @param width image display width	 * @param height image display height	 */	public PreloadImage(String url, int width, int height) {		this(url, width, height, true);	}	/**	 * Constructor	 * @param url image url	 * @param width image display width	 * @param height image display height	 * @param preloadFlg true for start preloading and showing the image	 */	public PreloadImage(String url, int width, int height, boolean preloadFlag) {		this(url, width, height, true, false, false);	}	/**	 * Constructor	 * @param url image url	 * @param width image display width	 * @param height image display height	 * @param preloadFlg true for start preloading and showing the image	 * @param animateEffect true for enable animation when displaying the image	 * @param hideFlag true for hidding the image and show it by calling show()	 */	public PreloadImage(String url, int width, int height, boolean preloadFlag, boolean animateEffect, boolean hideFlag) {		this(url, width, height, preloadFlag, animateEffect, hideFlag, false);	}			/**	 * Constructor	 * @param url image url	 * @param width image display width	 * @param height image display height	 * @param preloadFlg true for start preloading and showing the image	 * @param animateEffect true for enable animation when displaying the image	 * @param hideFlag true for hidding the image and show it by calling show()	 * @param cropMode true for cropping and centering the image	 */	public PreloadImage(String url, int width, int height, boolean preloadFlag, boolean animateEffect, boolean hideFlag, boolean cropMode) {		this.cropMode = cropMode;		this.url = url;		this.width = width;		this.height = height;		this.preloadFlg = preloadFlag;		this.animationEffectFlg = animateEffect;		this.hideFlag = hideFlag;		mainPanel = new SimplePanel();		initWidget(mainPanel);		mainPanel.getElement().getStyle().setOverflow(Overflow.HIDDEN);		mainPanel.setSize(width + Unit.PX.toString(), height + Unit.PX.toString());		preloadImageEventHandlers = new ArrayList<PreloadImageEventHandler>();		preloadPanel = new PopupPanel();		preloadPanel.getElement().getStyle().setZIndex(-1);		preloadPanel.getElement().getStyle().setOpacity(0);		preloadPanel.getElement().getStyle().setDisplay(Display.NONE);		if (this.preloadFlg) {			this.preLoadImageByUrl(url);		}			}	/**	 * preload and show image	 */	public void preLoadImage() {		this.preLoadImageByUrl(this.url);	}	/**	 * preload and show image by provided image url path	 * @param url image url path	 */	public void preLoadImageByUrl(String url) {		image = new Image(url);		for (int i = 0; i < this.mouseOverHandlers.size(); i++) {			image.addMouseOverHandler(this.mouseOverHandlers.get(i));		}		for (int i = 0; i < this.cliskHandlers.size(); i++) {			image.addClickHandler(this.cliskHandlers.get(i));		}		image.addLoadHandler(new LoadHandler() {			Image preloadImage = image;			private void moveImageHorizontally(int finalWidth){				relativeDirectionFlag = true;				relativeMoveDistance = (finalWidth - width)/2;			}						private void moveImageVerticaly(int finalHeight){				relativeDirectionFlag = false;				relativeMoveDistance = (finalHeight - height)/2;			}			public void onLoad(LoadEvent arg0) {				preloadPanel.getElement().getStyle().setDisplay(Display.BLOCK);				int offsetWidth = preloadImage.getOffsetWidth();				int offsetHeight = preloadImage.getOffsetHeight();				preloadPanel.getElement().getStyle().setDisplay(Display.NONE);				originalWidth = offsetWidth;				originalheight = offsetHeight;				/*				 * calculate new image width and height for resizing without affecting				 * the image scale				 */				int finalWidth = 0;				int finalHeight = 0;				if (offsetWidth == offsetHeight) {					if(!cropMode){						if (width > height) {							finalWidth = height;							finalHeight = height;							this.moveImageHorizontally(finalWidth);						} else {							finalWidth = width;							finalHeight = width;							this.moveImageVerticaly(finalHeight);						}					}else{						if (width > height) {							finalWidth = width;							finalHeight = width;							this.moveImageVerticaly(finalHeight);						} else {							finalWidth = height;							finalHeight = height;							this.moveImageHorizontally(finalWidth);						}					}									} else if (width > height) {					if(!cropMode){						if (offsetWidth > offsetHeight) {							if (offsetWidth * 1000 / offsetHeight - width * 1000 / height > 0) {								finalWidth = width;								finalHeight = width * offsetHeight / offsetWidth;								this.moveImageVerticaly(finalHeight);							} else {								finalWidth = height * offsetWidth / offsetHeight;								finalHeight = height;								this.moveImageHorizontally(finalWidth);							}						} else {							finalWidth = height * offsetWidth / offsetHeight;							finalHeight = height;							this.moveImageHorizontally(finalWidth);						}					}else{						if (offsetWidth > offsetHeight) {							if (offsetWidth * 1000 / offsetHeight - width * 1000 / height > 0) {								finalWidth = height * offsetWidth / offsetHeight;								finalHeight = height;								this.moveImageHorizontally(finalWidth);							} else {								finalWidth = width;								finalHeight = width * offsetHeight / offsetWidth;								this.moveImageVerticaly(finalHeight);							}						} else {							finalWidth = width;							finalHeight = width * offsetHeight / offsetWidth;							this.moveImageVerticaly(finalHeight);						}					}									} else {					if(!cropMode){						if (offsetWidth > offsetHeight) {							finalWidth = width;							finalHeight = width * offsetHeight / offsetWidth;							this.moveImageVerticaly(finalHeight);						} else {							if (offsetHeight * 1000 / offsetWidth - height * 1000 / width > 0) {								finalWidth = height * offsetWidth / offsetHeight;								finalHeight = height;								this.moveImageHorizontally(finalWidth);							} else {								finalWidth = width;								finalHeight = width * offsetHeight / offsetWidth;								this.moveImageVerticaly(finalHeight);							}						}					}else{						if (offsetWidth > offsetHeight) {							finalWidth = height * offsetWidth / offsetHeight;							finalHeight = height;							this.moveImageHorizontally(finalWidth);						} else {							if (offsetHeight * 1000 / offsetWidth - height * 1000 / width > 0) {								finalWidth = width;								finalHeight = width * offsetHeight / offsetWidth;								this.moveImageVerticaly(finalHeight);							} else {								finalWidth = height * offsetWidth / offsetHeight;								finalHeight = height;								this.moveImageHorizontally(finalWidth);							}						}					}									}				preloadImage.setPixelSize(finalWidth, finalHeight);				// remove the image from preload panel after preloading completed				preloadImage.removeFromParent();				mainPanel.clear();				if(animationEffectFlg && !hideFlag ){					hide();					// add the preloaded image to main panel					mainPanel.add(preloadImage);					show();									}else{					if(hideFlag){						hide();					}					// add the preloaded image to main panel					mainPanel.add(preloadImage);				}					//process image relative positive				preloadImage.getElement().getStyle().setPosition(Position.RELATIVE);				if(relativeDirectionFlag){					preloadImage.getElement().getStyle().setLeft(-1*relativeMoveDistance, Unit.PX);				}else{					preloadImage.getElement().getStyle().setTop(-1*relativeMoveDistance, Unit.PX);				}								preloadPanel.hide();				// add event for tell others about the end of image loading				for (int i = 0; i < preloadImageEventHandlers.size(); i++) {					preloadImageEventHandlers.get(i).onLoadCompleted();				}			}		});		// add the image to preloadPanel for starting the loading process		preloadPanel.clear();		preloadPanel.add(image);		preloadPanel.show();		// preloadImageEventHandlers.clear();	}	/**	 * get the image object	 * @return Image object	 */	public Image getImage() {		return this.image;	}	/**	 * @return widget width (not image width)	 */	public int getWidth() {		return this.width;	}	/**	 * @return widget height (not image height)	 */	public int getHeight() {		return this.height;	}	public void addMouseOverHandler(MouseOverHandler mouseOverHandler) {		if (this.mouseOverHandlers != null && image != null) {			this.mouseOverHandlers.add(mouseOverHandler);			for (int i = 0; i < this.mouseOverHandlers.size(); i++) {				image.addMouseOverHandler(this.mouseOverHandlers.get(i));			}		}	}	public void addPreloadImageEventHandlers(PreloadImageEventHandler preloadImageEventHandler) {		if (this.preloadImageEventHandlers != null) {			this.preloadImageEventHandlers.add(preloadImageEventHandler);		}	}	public void addClickHandler(ClickHandler mouseOverHandler) {		if (this.cliskHandlers != null && image != null) {			this.cliskHandlers.add(mouseOverHandler);			for (int i = 0; i < this.cliskHandlers.size(); i++) {				image.addClickHandler(this.cliskHandlers.get(i));			}		}	}	public void clear() {		preloadImageEventHandlers = new ArrayList<PreloadImageEventHandler>();	}	public int getOriginalWidth() {		return originalWidth;	}	public void setOriginalWidth(int originalWidth) {		this.originalWidth = originalWidth;	}	public int getOriginalheight() {		return originalheight;	}	public void setOriginalheight(int originalheight) {		this.originalheight = originalheight;	}		public boolean getAnimationEffectFlg(){		return this.animationEffectFlg;	}		public void setAnimationEffectFlg(boolean animationEffectFlg){		this.animationEffectFlg = animationEffectFlg;	}		public double getAnimationTime(){		return this.animationTime;	}		public void setAnimationTime(double animationTime){		this.animationTime = animationTime;	}		public void setHideFlag(boolean hideFlag){		this.hideFlag = hideFlag;	}	public boolean getHideFlag(){		return this.hideFlag;	}		public void show(){		this.hideFlag = true;		setImageAnimation();		if(this.animationEffectFlg){			new Timer() {		          @Override		          public void run() {		        	  image.getElement().getStyle().setOpacity(1);		          }		    }.schedule(10);		}else{			this.image.getElement().getStyle().setOpacity(1);		}			}		public void hide(){		this.hideFlag = true;		setImageAnimation();		this.image.getElement().getStyle().setOpacity(0);	}		private void setImageAnimation(){		if(this.animationEffectFlg){			this.image.getElement().getStyle().setProperty("webkitTransition", "all " + animationTime + "s ease-in-out");			this.image.getElement().getStyle().setProperty("Transition", "all " + animationTime + "s ease-in-out");		}else{			this.image.getElement().getStyle().setProperty("webkitTransition", "none");			this.image.getElement().getStyle().setProperty("Transition", "none");		}	}	}